# React

## 不同层级组件数据交互
### props
> 优点： 使用方便
> 缺点： 层级深以后过于复杂
### Context
> 优点： 层级深浅都可以方便共享数据
> 缺点： 组件复用性会变差
### compenent compostion(组件组合)
> 优点：不用传递很多`props`，使代码更加干净
> 缺点：会使高层组件变的更加复杂

## Context使用
### API
```React
React.createContext();
Context.Provider //使用Object.is判断是否相同
Context.Consumer
Context.diplayName
Class.contextType

```
### Class中使用
```
//定义
cosnt MyContext = React.createContext(defaultValue)

//引入
<MyContext.Provider value={/* 某个值 */}>

//赋值
class MyClass extends React.Component {
  render() {
    let value = this.context; // 使用一
  }
}
MyClass.contextType = MyContext;


//使用二
<MyContext.Consumer>
  {value => /* 基于 context 值进行渲染*/}
</MyContext.Consumer>

```
### 函数组件中使用

### 如何修改Context
> 可以给context传递一个函数，使consumers组件来更新context
```
const ThemeContext = React.createContext({
  theme: themes.dark,
  toggleTheme: () => {},
});
```

### 多个Content使用
```
// Theme context，默认的 theme 是 “light” 值
const ThemeContext = React.createContext('light');

// 用户登录 context
const UserContext = React.createContext({
  name: 'Guest',
});

class App extends React.Component {
  render() {
    const {signedInUser, theme} = this.props;

    // 提供初始 context 值的 App 组件
    return (
      <ThemeContext.Provider value={theme}>
        <UserContext.Provider value={signedInUser}>
          <Layout />
        </UserContext.Provider>
      </ThemeContext.Provider>
    );
  }
}

function Layout() {
  return (
    <div>
      <Sidebar />
      <Content />
    </div>
  );
}

// 一个组件可能会消费多个 context
function Content() {
  return (
    <ThemeContext.Consumer>
      {theme => (
        <UserContext.Consumer>
          {user => (
            <ProfilePage user={user} theme={theme} />
          )}
        </UserContext.Consumer>
      )}
    </ThemeContext.Consumer>
  );
}
```

### 注意
> `context`会根据`value`的`引用地址（reference identity）`判断是否重新渲染
```
// 父节点有更新Provider就会跟新
<MyContext.Provider value={{a: '1'}}>
  ...
<MyContext.Provider>

// 只用value更新才会重新渲染
var a = {a: '1'}
<MyContext.Provider value={a}>
  ...
<MyContext.Provider>
```